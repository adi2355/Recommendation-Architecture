# -*- coding: utf-8 -*-
"""ExampleCode.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1GJgyKW5woZWt_0wodLTA_XbRMwtGDka5
"""

import pandas as pd
import numpy as np
from sklearn.metrics.pairwise import cosine_similarity
from scipy import sparse
import time

class StrainMatchingEngine:
    """
    Strain Matching Engine for cannabis recommendation system

    This engine uses multi-vector weighted cosine similarity for matching user
    preferences to cannabis strains, with optimizations for mobile performance.
    """

    def __init__(self, strain_data_path):
        """Initialize the engine with strain data"""
        self.processed_data = None
        self.initialize(strain_data_path)

    def initialize(self, data_path):
        """Process strain data and prepare for recommendations"""
        print(f"Initializing Strain Matching Engine with data from: {data_path}")
        self.processed_data = self._preprocess_strain_data(data_path)
        print(f"Initialized with {len(self.processed_data['dataframe'])} strains")

    def _preprocess_strain_data(self, file_path):
        """
        Preprocess strain data for efficient similarity calculations

        Creates optimized vector representations of strain attributes
        using sparse matrices for memory efficiency
        """
        # Load data
        df = pd.read_csv(file_path)
        print(f"Loaded dataset with {df.shape[0]} strains and {df.shape[1]} columns")

        # Basic data cleaning
        df.columns = [col.lower() for col in df.columns]

        # Process text and numeric columns
        # [Implementation details removed]

        # Create feature encodings
        # [Implementation details removed]

        # Create processed data dictionary with necessary components
        return {
            'dataframe': df,
            'feature_columns': {},  # Feature column mapping
            'category_coverage': {},  # Data coverage statistics
            'sparse_vectors': {},  # Sparse matrix representations
            'category_weights': {},  # Feature category weights
            'similarity_cache': self._create_similarity_cache(),  # Caching system
            'correlation_data': {}  # Correlation information
        }

    def _create_similarity_cache(self, max_size=1000):
        """Create an LRU cache for similarity calculations"""
        # Simple cache implementation
        cache = {'get': lambda x: None, 'set': lambda x, y: None, 'get_stats': lambda: {}}
        return cache

    def get_strain_recommendations(self, strain_name, diversity=0.2, top_n=5):
        """
        Get strain recommendations similar to a reference strain

        Parameters:
        -----------
        strain_name : str
            Name of the reference strain
        diversity : float
            Controls diversity of recommendations (0-1)
        top_n : int
            Number of recommendations to return

        Returns:
        --------
        list
            Recommended strains with similarity scores and attributes
        """
        df = self.processed_data['dataframe']

        # Find strain in database
        try:
            strain_index = df[df['name'] == strain_name].index[0]
        except (IndexError, KeyError):
            return f"Strain '{strain_name}' not found in dataset."

        # Calculate strain similarities
        # [Implementation details removed]

        # Apply diversity selection
        # [Implementation details removed]

        # Format recommendations
        recommendations = [
            {
                'rank': i+1,
                'name': f"Sample Strain {i+1}",
                'classification': "Sample Type",
                'similarity_score': 0.9 - (i * 0.05),
                'confidence_score': 95 - (i * 5),
                'attributes': {
                    'effects': ['Sample Effect 1', 'Sample Effect 2'],
                    'flavors': ['Sample Flavor']
                }
            }
            for i in range(top_n)
        ]

        return recommendations

    def get_preference_recommendations(self, preferences, diversity=0.3, top_n=5):
        """
        Get strain recommendations based on user preferences

        Parameters:
        -----------
        preferences : dict
            Dictionary of user preferences by category
        diversity : float
            Controls diversity of recommendations (0-1)
        top_n : int
            Number of recommendations to return

        Returns:
        --------
        list
            Recommended strains with similarity scores and attributes
        """
        # Check preferences format
        if not isinstance(preferences, dict) or not preferences:
            return "Invalid preferences format"

        # Calculate match to preferences
        # [Implementation details removed]

        # Apply diversity selection
        # [Implementation details removed]

        # Format recommendations
        recommendations = [
            {
                'rank': i+1,
                'name': f"Preference Match {i+1}",
                'classification': "Sample Type",
                'similarity_score': 0.95 - (i * 0.05),
                'confidence_score': 98 - (i * 3),
                'attributes': {
                    'effects': ['Matched Effect 1', 'Matched Effect 2'],
                    'flavors': ['Matched Flavor']
                },
                'matches': ['Matched Preference 1', 'Matched Preference 2']
            }
            for i in range(top_n)
        ]

        return recommendations


# Demo usage
if __name__ == "__main__":
    # Initialize engine with strain data
    engine = StrainMatchingEngine("sample_strains.csv")

    # Get strain-based recommendations
    strain_recommendations = engine.get_strain_recommendations("Blue Dream", diversity=0.2, top_n=5)

    # Print recommendations
    print("\nSTRAIN-BASED RECOMMENDATIONS:")
    for rec in strain_recommendations:
        print(f"{rec['rank']}. {rec['name']} - Score: {rec['similarity_score']:.2f}, "
              f"Confidence: {rec['confidence_score']}%")
        print(f"   Top effects: {', '.join(rec['attributes']['effects'][:3])}")

    # Get preference-based recommendations
    test_preferences = {
        'strain_type': ['Sativa'],
        'effects': ['Energetic', 'Creative', 'Focused'],
        'medical': ['Depression', 'Fatigue']
    }

    pref_recommendations = engine.get_preference_recommendations(
        test_preferences, diversity=0.3, top_n=5)

    # Print recommendations
    print("\nPREFERENCE-BASED RECOMMENDATIONS:")
    for rec in pref_recommendations:
        print(f"{rec['rank']}. {rec['name']} - Score: {rec['similarity_score']:.2f}, "
              f"Confidence: {rec['confidence_score']}%")
        print(f"   Matching preferences: {', '.join(rec['matches'][:3])}")